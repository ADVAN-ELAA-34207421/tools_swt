// ext.androidHostOut is shared by all tools/{base,build,swt} gradle projects/
ext.androidHostOut = java.lang.System.getenv("ANDROID_HOST_OUT")
ext.androidHostOut = file(ext.androidHostOut != null ?
                              ext.androidHostOut :
                              "$rootDir/../../out/host/common")
ext.androidRootDir = file(new File(ext.androidHostOut, "../../../"))
// rootProject.buildDir is specific to this gradle build.
buildDir = new File(file(ext.androidHostOut), "tools/swt/build")

def getVersion(Project p, String baseVersion) {
    if (p.has("release")) {
        return baseVersion
    }

    return baseVersion + '-SNAPSHOT'
}

subprojects {
    // Change buildDir first so that all plugins pick up the new value.
    project.buildDir = project.file("$project.parent.buildDir/../$project.name")

    apply plugin: 'java'
    apply plugin: 'maven'
    apply plugin: 'findbugs'

    repositories {
        mavenCentral()
        maven { url = uri("$rootProject.ext.androidHostOut/repo") }
    }

    ext.baseVersion = '22.0'

    version = getVersion(project, ext.baseVersion)

    // set all java compilation to use UTF-8 encoding.
    tasks.withType(JavaCompile) {
        options.encoding = 'UTF-8'
    }

    task disableTestFailures << {
        tasks.withType(Test) {
            ignoreFailures = true
        }
    }

    project.ext.getClassPath = {
        String classPath = ""
        project.configurations.runtime.files.each { file ->
            String name = file.name

            // handle tools/base lib that don't have the -SNAPSHOT on them
            String versionPattern = "(.*)-${ext.baseVersion}-\\d+\\.\\d+-\\d+\\.jar"
            if (java.util.regex.Pattern.matches(versionPattern, name)) {
                name = name.replaceFirst(versionPattern, '$1.jar');
            } else {
                // now handle tools/swt libs with the -SNAPSHOT.
                String suffix = "-" + project.version + ".jar"
                if (name.endsWith(suffix)) {
                    name = name.substring(0, name.size() - suffix.size()) + ".jar"
                } else if (name.equals("swt.jar")) {
                    // now handle swt.jar which should be removed as we add this manually later.
                    name = "";
                }
            }

            if (name.size() > 0) {
                classPath = classPath + " " + name
            }
        }
        return classPath
    }

    task prebuiltJar(type: Jar) {
        from(sourceSets.main.output)
    }

    task distZip(type: Zip) {
        from(prebuiltJar) {
            rename "(.*)-${project.version}-.*.jar", '$1.jar'
        }
        from(project.configurations.runtime) {
            rename "(.*)-${project.version}-.*.jar", '$1.jar'
        }

        archiveName archivesBaseName + ".zip"
    }

    // delay computing the manifest classpath only if the
    // prebuiltJar task is set to run.
    project.gradle.taskGraph.whenReady { taskGraph ->
        if (taskGraph.hasTask(prebuiltJar)) {
            prebuiltJar.manifest.attributes("Class-Path": project.ext.getClassPath())
        }
    }

    // add javadoc/source jar tasks as artifacts
    artifacts {
        archives jar
    }

    task publishLocal(type: Upload) {
        configuration = configurations.archives
        repositories {
            mavenDeployer {
                repository(url: uri("$rootProject.ext.androidHostOut/repo"))
            }
        }
    }

    findbugs {
        ignoreFailures = true
        effort = "max"
        reportLevel = "high"
    }

}

// delay evaluation of this project before all subprojects have been evaluated.
subprojects.each { subproject -> evaluationDependsOn(subproject.name) }

def testTasks = subprojects.collect { it.tasks.withType(Test) }.flatten()

task aggregateResults(type: Copy) {
    from { testTasks*.testResultsDir }
    into { file("$buildDir/results") }
}
